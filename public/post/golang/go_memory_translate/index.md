
<!--more-->

https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44

Go语言的内存管理是由标准库完成的，？？。 即使开发者不需要与内存管理打交道，go语言的内存管理仍然做了很多优化，并且有一些很有趣的概念。 在堆(Heap)上分配内存。 设计go语言的内存管理，主要是是为了加速其再并发环境下的性能，以及与配合垃圾回收器(GC)进行工作。 下边让我们先看一个简单的例子。

注释 //go:noinline 会让程序不要做过度优化，使的编译后的汇编中直接将函数调用过程编译进去， 那样也就不会有分配内存的操作。 运行逃逸分析的命令 go tool compile “-m” main.go 会证实Go做的内存分配的操作。

运行 go tool compile -S main.go，那样我们就可以看到该程序的汇编代码 可以看到管理内存分配的内嵌函数 newobject在起作用，而该函数最终是调用mallocgc进行在堆上的内存管理。GO语言对于大小不同的内存分配需求，会采取不同的策略。

小内存分配策略 对于小于32KB的小内存分配。Go会试着从一个本地的内存mache上进行分配，该缓存管理着一些 大小是32KB的mspan. mspan包含的这些内存则是专门用于分配内存的。 每一个线程M 分配给一个处理器P，同时一个处理器P同时最多接受一个goroutine。 当进行分配内存操作的时候。当前的goroutine会使用对于当前P的本地缓存，并找到在span上第一个可用的object。因为不用加锁，所以可以大大加快内存分配的速度以及运行效率。

Span list被分成70个不同大小的类，从8个字节到32k个字节。那样可以存储不同的大小的对象。

每一个span存在于两个地方，一个是不包含指针的列表。另一个是包含指针的数组。这样设计可以更方便GC进行回收内存的操作，因为它不用再遍历那个没有指针的数组。

在之前的列子当中，结构体的大小是32byte，因此会调用32bytes的span。这里如果没有一个32bytes的内存会怎么办呢？Go维护一个mcentral的结构，里边有spans的数据列表。这些spans包含着可用以及不可用的对象。

mcentral 保持着一个双向链表的spans， 在非空数组中的span 意味着至少有一个槽是可以进行内存分配操作的。当个GC进行回收内存的操作时，它可以清除这部分并把它放到非空的数组里。 我们的程序如果发现cache的内存耗尽了，俺么它就会想centrial 数组申请一个块内存。 Go需要一种可以再central中也没有可用内存申请spans的方法。那就是从heap上申请，并链接到central上去。 堆从操作系统上申请内存。如果需要更多的内存，堆会申请一串内存，称为arena。其中64mb是为了64位架构的机器，4mb为了其它架构的机器。 Arena也会简历内存页和spans的映射关系。

大内存分配 Go语言不会使用local的cache去管理大的内存分配。这些大于32KB的内存分配，会向上取整到页大小而且这些页也会直接在堆上分配。

总体概况 现在我们在一个比较高的层次上理解了内存分配究竟发生了什么。现在让我们画出所有的部件，以便理解整个图片。

启发 内存分配原先是基于Tcmalloc做的，tcmalloc是Google主导的一个为并行环境下优化的内存分配器。TCmalloc的文档很值得一读，在这里可以找到我们上边提到的各个概念。

