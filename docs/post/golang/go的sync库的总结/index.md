
<!--more-->


这里主要涉及我自己比较不熟悉的一些库的总结

1. Sync.Once 保证程序只执行一次，应用场景如下。
单列模式
一些不能重复执行的资源，比如文件句柄，数据库连接等
close channel

2. Sync.Map sync.Map是golang1.9关于并发读写Map的解决方案。 在1.9之前对map的读写主要应用使得RW锁加map的方法进行解决。 或者实现分段加锁的方式进行解决。 这两种方法要不性能不行，要不实现太过复杂。go采取的方式与其不同，其主要利用空间换时间的思想。设置两个map，一个read的，一个write的。这样就算在write加锁，那么read上边依然可以提供读写服务。 参考文章
   
3. Sync.Pool
我简单总结下其的设计思路。对于一个Pool。其最直接的想法就是利用一个队列，将其全部存储到其中。Put，Get分别对应其中的进队列和出队列。 这种方式但从work的角度来讲是没有问题的，但是有一个问题就是对于golang这种一般都有多个G在跑的程序，势必会造成竞争的问题。所以此处Golang选择每个P上设置自己的一定的内存空间，这样对于一个G的 申请和释放内存，有很大的概率在自己的P上就可以解决。这样的话有可能没有加锁，或者加锁冲突的概率大大减少。 参考文章
